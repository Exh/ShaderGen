struct TestShaders_VeldridShaders_ForwardMtlCombined_LightInfoBuffer
{
    float3 LightDir;
    float __padding;
};

struct TestShaders_VeldridShaders_ForwardMtlCombined_CameraInfoBuffer
{
    float3 CameraPosition_WorldSpace;
    float __padding1;
    float3 CameraLookDirection;
    float __padding2;
};

struct TestShaders_VeldridShaders_ForwardMtlCombined_PointLightInfo
{
    float3 Position;
    float Range;
    float3 Color;
    float __padding;
};

struct TestShaders_VeldridShaders_ForwardMtlCombined_PointLightsBuffer
{
    int NumActiveLights;
    float _padding0;
    float _padding1;
    float _padding2;
    TestShaders_VeldridShaders_ForwardMtlCombined_PointLightInfo PointLights[4];
};

struct TestShaders_VeldridShaders_ForwardMtlCombined_MaterialPropertiesBuffer
{
    float3 SpecularIntensity;
    float SpecularPower;
};

struct TestShaders_VeldridShaders_ForwardMtlCombined_VertexInput
{
    float3 Position : POSITION0;
    float3 Normal : NORMAL0;
    float2 TexCoord : TEXCOORD0;
};

struct TestShaders_VeldridShaders_ForwardMtlCombined_PixelInput
{
    float4 Position : SV_Position;
    float3 Position_WorldSpace : POSITION0;
    float4 LightPosition : TEXCOORD0;
    float3 Normal : NORMAL0;
    float2 TexCoord : TEXCOORD1;
};

cbuffer ProjectionBuffer : register(b0)
{
    float4x4 Projection;
}

cbuffer ViewBuffer : register(b1)
{
    float4x4 View;
}

cbuffer WorldBuffer : register(b2)
{
    float4x4 World;
}

cbuffer InverseTransposeWorldBuffer : register(b3)
{
    float4x4 InverseTransposeWorld;
}

cbuffer LightProjectionBuffer : register(b4)
{
    float4x4 LightProjection;
}

cbuffer LightViewBuffer : register(b5)
{
    float4x4 LightView;
}


TestShaders_VeldridShaders_ForwardMtlCombined_PixelInput VS
TestShaders_VeldridShaders_ForwardMtlCombined_VertexInput input)
{
    TestShaders_VeldridShaders_ForwardMtlCombined_PixelInput output;
    float4 worldPosition = mul(World, float4(input.Position, 1));
    float4 viewPosition = mul(View, worldPosition);
    output.Position = mul(Projection, viewPosition);
    output.Position_WorldSpace = float3(worldPosition.x, worldPosition.y, worldPosition.z);
    float4 outNormal = mul(InverseTransposeWorld, float4(input.Normal, 1));
    output.Normal = normalize(float3(outNormal.x, outNormal.y, outNormal.z));
    output.TexCoord = input.TexCoord;
    output.LightPosition = mul(World, float4(input.Position, 1));
    output.LightPosition = mul(LightView, output.LightPosition);
    output.LightPosition = mul(LightProjection, output.LightPosition);
    return output;
}
