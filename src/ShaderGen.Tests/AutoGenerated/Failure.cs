using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using ShaderGen.Tests.Tools;

namespace ShaderGen.Tests.AutoGenerated
{
    internal class Failure
    {
        public readonly MethodMap MethodMap;
        private object[] Parameters;
        private IReadOnlyList<(object Result, IReadOnlyList<TestSet> TestSets)> Results;
        private readonly string _string;

        public Failure(MethodMap methodMap, object[] parameters,
            IReadOnlyList<(object Result, IReadOnlyList<TestSet> TestSets)> results)
        {
            MethodMap = methodMap;
            Parameters = parameters;
            Results = results;

            MethodInfo method = MethodMap.Method;
            StringBuilder builder = new StringBuilder()
                .Append(method.Name)
                .Append('(')
                .Append(string.Join(", ", parameters))
                .Append(')');

            (string Name, object Value)[] resultGroups = results.Select(r => (Name: string.Join(", ", r.TestSets.Select(t => t.Name)), Value: r.Result)).ToArray();
            int pad = resultGroups.Max(r => r.Name.Length) + 3;
            foreach ((string Name, object Value) group in resultGroups)
            {
                builder.AppendLine(string.Empty)
                    .AppendFormat(group.Name.PadLeft(pad))
                    .Append(" = ")
                    .Append(group.Value);
            }

            _string = builder.ToString();
        }

        public static Failure Test(
            TestSets testSets,
            MethodMap methodMap,
            PaddedStructCreator.Field resultField,
            int test)
        {
            // Get results
            IEqualityComparer<object> comparer = new FloatComparer();
            IReadOnlyList<(object Result, IReadOnlyList<TestSet> TestSets)> results = testSets
                .Select(t => (TestSet: t, Result: methodMap.GetResult(t.Results, test)))
                .GroupBy(r => r.Result, r => r.TestSet, comparer)
                .Select(g => (Result: g.Key, TestSets: (IReadOnlyList<TestSet>)g.ToArray()))
                .OrderByDescending(g => g.TestSets.Count)
                .ToArray();

            if (results.Count == 1)
            {
                // Results were all identical!
                return null;
            }

            return new Failure(methodMap, methodMap.GetParameters(testSets.TestData, test), results);
        }

        /// <summary>
        /// Returns a <see cref="System.String" /> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String" /> that represents this instance.
        /// </returns>
        public override string ToString() => _string;

        /// <summary>
        /// Compares floats
        /// </summary>
        /// <seealso cref="object" />
        private class FloatComparer : IEqualityComparer<object>
        {
            private static ConcurrentDictionary<Type, IReadOnlyCollection<FieldInfo>> _childFieldInfos
                = new ConcurrentDictionary<Type, IReadOnlyCollection<FieldInfo>>();

            /// <summary>
            /// Determines whether the specified <see cref="System.Object" />, is equal to this instance.
            /// </summary>
            /// <param name="a">The <see cref="System.Object" /> to compare with this instance.</param>
            /// <param name="b">The b.</param>
            /// <returns>
            ///   <c>true</c> if the specified <see cref="System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            /// </returns>
            public bool Equals(object a, object b)
            {
                if (object.Equals(a, b))
                {
                    return true;
                }

                Type currentType = a?.GetType() ?? b.GetType();
                if (currentType == typeof(float))
                {
                    return ((float)a).ApproximatelyEqual((float)b, 1.0f);
                }

                object aValue = a;
                object bValue = b;
                Stack<(Type currentType, object aValue, object bValue)> stack
                    = new Stack<(Type currentType, object aValue, object bValue)>();
                stack.Push((currentType, aValue, bValue));

                while (stack.Count > 0)
                {
                    // Pop top of stack.
                    (currentType, aValue, bValue) = stack.Pop();

                    // Get fields (cached)
                    IReadOnlyCollection<FieldInfo> childFields = _childFieldInfos.GetOrAdd(currentType, t => t.GetFields().Where(f => !f.IsStatic).ToArray());

                    if (childFields.Count < 1)
                    {
                        // No child fields, we have an inequality
                        return false;
                    }

                    foreach (FieldInfo childField in childFields)
                    {
                        object aMemberValue = childField.GetValue(aValue);
                        object bMemberValue = childField.GetValue(bValue);

                        currentType = childField.FieldType;
                        // Short cut equality
                        if (object.Equals(aMemberValue, bMemberValue) ||
                            currentType == typeof(float) && ((float)aMemberValue).ApproximatelyEqual((float)bMemberValue))
                        {
                            continue;
                        }

                        stack.Push((currentType, aMemberValue, bMemberValue));
                    }
                }

                return true;
            }

            public int GetHashCode(object obj)
            {
                // Note we will get loads of collisions and rely instead on equality.
                return 0;
            }
        }
    }

}