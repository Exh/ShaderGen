using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using Xunit;

namespace ShaderGen.Tests.AutoGenerated
{
    /// <summary>
    /// Holds information about the mapping of a tested method parameters and return to a buffer.
    /// </summary>
    internal class MethodMap
    {
        /// <summary>
        /// The index of the method.
        /// </summary>
        public readonly int Index;

        /// <summary>
        /// The method info.
        /// </summary>
        public readonly MethodInfo Method;

        /// <summary>
        /// The parameter to field name map.
        /// </summary>
        public readonly IReadOnlyDictionary<ParameterInfo, string> Parameters;

        /// <summary>
        /// The return value to field name map.
        /// </summary>
        public readonly string Return;

        private string _signature;

        /// <summary>
        /// Initializes a new instance of the <see cref="MethodMap"/> class.
        /// </summary>
        /// <param name="index">The index.</param>
        /// <param name="method">The method.</param>
        /// <param name="parameters">The parameters.</param>
        /// <param name="return">The return.</param>
        public MethodMap(int index, MethodInfo method, IReadOnlyDictionary<ParameterInfo, string> parameters, string @return)
        {
            Index = index;
            Method = method;
            Parameters = parameters;
            Return = @return;
            Signature =
                $"{method.ReturnType.Name} {method.DeclaringType.FullName}.{method.Name}({String.Join(", ", Parameters.Select(p => $"{p.Key.ParameterType.Name} {p.Key.Name}"))})";
        }

        /// <summary>
        /// Gets the signature.
        /// </summary>
        /// <value>
        /// The signature.
        /// </value>
        public string Signature { get; private set; }

        /// <summary>
        /// Generates test data for this method, executes it and stores the result.
        /// </summary>
        /// <param name="mapping">The mapping.</param>
        /// <param name="testData">The test data.</param>
        /// <param name="dataOffset">The data offset.</param>
        /// <param name="results">The results.</param>
        /// <param name="resultsOffset">The results offset.</param>
        public unsafe void GenerateTestData(Mappings mapping, byte[] testData, int dataOffset, byte[] results, int resultsOffset)
        {
            // TODO I suspect this can all be done a lot easier with Span<T> once upgraded to .Net Core 2.1
            object[] parameters = new object[Parameters.Count];
            GCHandle handle;
            IntPtr ptr;

            // Create random input values
            foreach (KeyValuePair<ParameterInfo, string> kvp in Parameters)
            {
                ParameterInfo pInfo = kvp.Key;
                PaddedStructCreator.Field field = mapping.BufferFields[kvp.Value];
                int floatCount = (int)Math.Ceiling(
                    (float)Math.Max(field.AlignmentInfo.ShaderSize, field.AlignmentInfo.CSharpSize) /
                    sizeof(float));

                // Get random floats to fill parameter structure
                float[] floats = TestUtil.GetRandomFloats(floatCount);
                handle = GCHandle.Alloc(floats, GCHandleType.Pinned);
                try
                {
                    // Create object of correct type
                    ptr = Marshal.AllocCoTaskMem(field.AlignmentInfo.CSharpSize);
                    Marshal.Copy(floats, 0, ptr, floats.Length);
                    parameters[pInfo.Position] = Marshal.PtrToStructure(ptr, field.Type);

                    // Fill test data
                    ptr = Marshal.UnsafeAddrOfPinnedArrayElement(testData, dataOffset + field.Position);
                    Marshal.Copy(floats, 0, ptr, floats.Length);
                }
                finally
                {
                    handle.Free();
                }
            }

            object result = Method.Invoke(null, parameters);

            if (Return == null)
            {
                Assert.Null(result);
                return;
            }

            PaddedStructCreator.Field resultField = mapping.BufferFields[Return];
            handle = GCHandle.Alloc(result, GCHandleType.Pinned);
            try
            {
                // Fill test data
                Marshal.Copy(handle.AddrOfPinnedObject(), results, resultsOffset, resultField.AlignmentInfo.ShaderSize);
            }
            finally
            {
                handle.Free();
            }
        }
    }
}